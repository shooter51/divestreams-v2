name: Deploy Environment

# Orchestrator-triggered deployment to a specific environment.
# Builds Docker image, deploys to VPS, and calls back with result.

on:
  workflow_dispatch:
    inputs:
      pipeline_id:
        description: 'Pipeline run ID from orchestrator'
        required: true
        type: string
      environment:
        description: 'Target environment: dev, test, production'
        required: true
        type: string
      image_tag:
        description: 'Docker image tag to build/deploy'
        required: true
        type: string
      commit_sha:
        description: 'Commit SHA being deployed'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: shooter51/divestreams-app
  ORCHESTRATOR_URL: http://62.72.3.35

jobs:
  # ─────────────────────────────────────────────
  # Build Docker image
  # ─────────────────────────────────────────────
  build:
    runs-on: [self-hosted, linux, divestreams]
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.image_tag }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.commit_sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ─────────────────────────────────────────────
  # Deploy to Dev VPS
  # ─────────────────────────────────────────────
  deploy-dev:
    needs: build
    if: inputs.environment == 'dev'
    runs-on: [self-hosted, linux, divestreams]
    environment: dev
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Deploy to Dev VPS
        run: |
          echo "Deploying to Dev VPS (${{ vars.DEV_VPS_ID }})"
          curl -X POST \
            "https://developers.hostinger.com/api/vps/v1/virtual-machines/${{ vars.DEV_VPS_ID }}/docker/divestreams-dev/update" \
            -H "Authorization: Bearer ${{ secrets.HOSTINGER_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --fail

      - name: Wait for containers to be ready
        run: |
          echo "Polling dev containers until ready (timeout 120s)..."
          DEADLINE=$((SECONDS + 120))
          while [ $SECONDS -lt $DEADLINE ]; do
            RESPONSE=$(curl -s -X GET \
              "https://developers.hostinger.com/api/vps/v1/virtual-machines/${{ vars.DEV_VPS_ID }}/docker/divestreams-dev/containers" \
              -H "Authorization: Bearer ${{ secrets.HOSTINGER_API_TOKEN }}" \
              -H "Content-Type: application/json")
            RUNNING_COUNT=$(echo "$RESPONSE" | jq '[.[] | select(.state == "running")] | length' 2>/dev/null || echo "0")
            echo "[${SECONDS}s] Running containers: $RUNNING_COUNT"
            if [ "$RUNNING_COUNT" -ge 3 ]; then
              echo "Dev containers are running"
              exit 0
            fi
            sleep 10
          done
          echo "ERROR: Timed out waiting for dev containers"
          exit 1

      - name: Record deployment to dev environment
        run: |
          npx pact-broker record-deployment \
            --pacticipant DiveStreamsAPI \
            --version ${{ inputs.commit_sha }} \
            --environment dev \
            --broker-base-url http://62.72.3.35:9292
        continue-on-error: true

      - name: Callback to orchestrator
        if: always()
        run: |
          SUCCESS="true"
          ERROR=""
          if [ "${{ job.status }}" != "success" ]; then
            SUCCESS="false"
            ERROR="Dev deployment failed"
          fi

          curl -s -X POST "${{ env.ORCHESTRATOR_URL }}/api/deploy-complete" \
            -H "Authorization: Bearer ${{ secrets.ORCHESTRATOR_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg pid "${{ inputs.pipeline_id }}" \
              --arg env "dev" \
              --argjson success "$SUCCESS" \
              --arg error "$ERROR" \
              '{pipeline_id: $pid, environment: $env, success: $success, error: $error}'
            )" || echo "Orchestrator callback failed (non-fatal)"

  # ─────────────────────────────────────────────
  # Deploy to Test VPS
  # ─────────────────────────────────────────────
  deploy-test:
    needs: build
    if: inputs.environment == 'test'
    runs-on: [self-hosted, linux, divestreams]
    environment: test
    steps:
      - name: Validate required secrets
        env:
          B2_ENDPOINT: ${{ secrets.B2_ENDPOINT }}
          B2_REGION: ${{ secrets.B2_REGION }}
          B2_BUCKET: ${{ secrets.B2_BUCKET }}
          B2_KEY_ID: ${{ secrets.B2_KEY_ID }}
          B2_APP_KEY: ${{ secrets.B2_APP_KEY }}
          CDN_URL: ${{ secrets.CDN_URL }}
          STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          TEST_VPS_SSH_KEY: ${{ secrets.TEST_VPS_SSH_KEY }}
          HOSTINGER_API_TOKEN: ${{ secrets.HOSTINGER_API_TOKEN }}
        run: |
          ERRORS=0
          for var in B2_ENDPOINT B2_REGION B2_BUCKET B2_KEY_ID B2_APP_KEY CDN_URL STRIPE_WEBHOOK_SECRET TEST_VPS_SSH_KEY HOSTINGER_API_TOKEN; do
            eval val=\$$var
            if [ -z "$val" ]; then
              echo "ERROR: $var is not set"
              ERRORS=$((ERRORS + 1))
            fi
          done
          if [ $ERRORS -gt 0 ]; then
            echo "DEPLOYMENT BLOCKED: $ERRORS secret(s) missing"
            exit 1
          fi
          echo "All secrets validated"

      - name: Setup SSH key for test VPS
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.TEST_VPS_SSH_KEY }}" > ~/.ssh/test_key
          chmod 600 ~/.ssh/test_key
          ssh-keyscan -H ${{ vars.TEST_VPS_IP }} >> ~/.ssh/known_hosts

      - name: Update environment secrets on test VPS
        env:
          B2_ENDPOINT: ${{ secrets.B2_ENDPOINT }}
          B2_REGION: ${{ secrets.B2_REGION }}
          B2_BUCKET: ${{ secrets.B2_BUCKET }}
          B2_KEY_ID: ${{ secrets.B2_KEY_ID }}
          B2_APP_KEY: ${{ secrets.B2_APP_KEY }}
          CDN_URL: ${{ secrets.CDN_URL }}
          STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
        run: |
          cat > /tmp/update-env.sh << 'ENVSCRIPT'
          #!/bin/bash
          cd /docker/divestreams-test
          cp .env .env.backup-$(date +%Y%m%d-%H%M%S)
          for var in B2_ENDPOINT B2_REGION B2_BUCKET B2_KEY_ID B2_APP_KEY CDN_URL STRIPE_WEBHOOK_SECRET; do
            eval val=\$$var
            grep -q "^${var}=" .env && sed -i "s|^${var}=.*|${var}=${val}|" .env || echo "${var}=${val}" >> .env
          done
          echo "Environment secrets updated"
          ENVSCRIPT

          sed -i "s|PLACEHOLDER_B2_ENDPOINT|$B2_ENDPOINT|g" /tmp/update-env.sh
          cat /tmp/update-env.sh | ssh -i ~/.ssh/test_key -o StrictHostKeyChecking=no root@${{ vars.TEST_VPS_IP }} 'bash -s'

      - name: Deploy to Test VPS
        run: |
          echo "Deploying to Test VPS (${{ vars.TEST_VPS_ID }})"
          curl -X POST \
            "https://developers.hostinger.com/api/vps/v1/virtual-machines/${{ vars.TEST_VPS_ID }}/docker/divestreams-test/update" \
            -H "Authorization: Bearer ${{ secrets.HOSTINGER_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --fail

      - name: Wait for containers to be ready
        run: |
          echo "Polling test containers until ready (timeout 120s)..."
          DEADLINE=$((SECONDS + 120))
          while [ $SECONDS -lt $DEADLINE ]; do
            RESPONSE=$(curl -s -X GET \
              "https://developers.hostinger.com/api/vps/v1/virtual-machines/${{ vars.TEST_VPS_ID }}/docker/divestreams-test/containers" \
              -H "Authorization: Bearer ${{ secrets.HOSTINGER_API_TOKEN }}" \
              -H "Content-Type: application/json")
            RUNNING_COUNT=$(echo "$RESPONSE" | jq '[.[] | select(.state == "running")] | length' 2>/dev/null || echo "0")
            echo "[${SECONDS}s] Running containers: $RUNNING_COUNT"
            if [ "$RUNNING_COUNT" -ge 4 ]; then
              echo "All containers running on Test VPS"
              exit 0
            fi
            sleep 10
          done
          echo "ERROR: Timed out waiting for test containers"
          exit 1

      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Record deployment to test environment
        run: |
          npx pact-broker record-deployment \
            --pacticipant DiveStreamsAPI \
            --version ${{ inputs.commit_sha }} \
            --environment test \
            --broker-base-url http://62.72.3.35:9292
        continue-on-error: true

      - name: Callback to orchestrator
        if: always()
        run: |
          SUCCESS="true"
          ERROR=""
          if [ "${{ job.status }}" != "success" ]; then
            SUCCESS="false"
            ERROR="Test deployment failed"
          fi

          curl -s -X POST "${{ env.ORCHESTRATOR_URL }}/api/deploy-complete" \
            -H "Authorization: Bearer ${{ secrets.ORCHESTRATOR_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg pid "${{ inputs.pipeline_id }}" \
              --arg env "test" \
              --argjson success "$SUCCESS" \
              --arg error "$ERROR" \
              '{pipeline_id: $pid, environment: $env, success: $success, error: $error}'
            )" || echo "Orchestrator callback failed (non-fatal)"

  # ─────────────────────────────────────────────
  # Deploy to Production VPS
  # ─────────────────────────────────────────────
  deploy-production:
    needs: build
    if: inputs.environment == 'production'
    runs-on: [self-hosted, linux, divestreams]
    environment: production
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Pact can-i-deploy gate
        run: npm run pact:can-deploy:production
        env:
          PACT_BROKER_BASE_URL: http://62.72.3.35:9292
          GITHUB_SHA: ${{ inputs.commit_sha }}
          GITHUB_REF_NAME: main

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Retag test image as latest
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:test
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:test ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Deploy to production VPS
        run: |
          echo "Deploying to Production VPS (${{ vars.PROD_VPS_ID }})"
          curl -X POST \
            "https://developers.hostinger.com/api/vps/v1/virtual-machines/${{ vars.PROD_VPS_ID }}/docker/divestreams-prod/update" \
            -H "Authorization: Bearer ${{ secrets.HOSTINGER_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --fail

      - name: Wait for containers to be ready
        run: |
          echo "Polling production containers until ready (timeout 120s)..."
          DEADLINE=$((SECONDS + 120))
          while [ $SECONDS -lt $DEADLINE ]; do
            RESPONSE=$(curl -s -X GET \
              "https://developers.hostinger.com/api/vps/v1/virtual-machines/${{ vars.PROD_VPS_ID }}/docker/divestreams-prod/containers" \
              -H "Authorization: Bearer ${{ secrets.HOSTINGER_API_TOKEN }}" \
              -H "Content-Type: application/json")
            RUNNING_COUNT=$(echo "$RESPONSE" | jq '[.[] | select(.state == "running")] | length' 2>/dev/null || echo "0")
            echo "[${SECONDS}s] Running containers: $RUNNING_COUNT"
            if [ "$RUNNING_COUNT" -ge 4 ]; then
              echo "All containers running in production"
              exit 0
            fi
            sleep 10
          done
          echo "ERROR: Timed out waiting for production containers"
          exit 1

      - name: Record deployment to production environment
        run: |
          npx pact-broker record-deployment \
            --pacticipant DiveStreamsAPI \
            --version ${{ inputs.commit_sha }} \
            --environment production \
            --broker-base-url http://62.72.3.35:9292
        continue-on-error: true

      - name: Callback to orchestrator
        if: always()
        run: |
          SUCCESS="true"
          ERROR=""
          if [ "${{ job.status }}" != "success" ]; then
            SUCCESS="false"
            ERROR="Production deployment failed"
          fi

          curl -s -X POST "${{ env.ORCHESTRATOR_URL }}/api/deploy-complete" \
            -H "Authorization: Bearer ${{ secrets.ORCHESTRATOR_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg pid "${{ inputs.pipeline_id }}" \
              --arg env "production" \
              --argjson success "$SUCCESS" \
              --arg error "$ERROR" \
              '{pipeline_id: $pid, environment: $env, success: $success, error: $error}'
            )" || echo "Orchestrator callback failed (non-fatal)"
