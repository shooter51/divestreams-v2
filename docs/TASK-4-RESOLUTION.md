# Task 4 Resolution: PADI Static JSON Catalog - Source Data Approach

## Issue

The spec reviewer identified that the JSON catalog structure didn't align with the `agency_course_templates` database schema. Missing fields like `agencyId`, `contentHash`, `sourceType`, timestamps, etc.

## Resolution: Option A - Source Data Format

After reviewing the implementation plan (especially Task 9 - Seed Script), I determined that **Option A is correct**. The static JSON catalogs are **SOURCE DATA** that will be transformed by the seed/sync script, not direct database dumps.

## What Changed

### 1. Added Documentation to JSON File
**File:** `/lib/data/catalogs/padi-courses.json`

Added header comments explaining:
```json
{
  "$schema": "../../schemas/agency-catalog.schema.json",
  "_comment": "PADI Course Catalog - Source Data",
  "_note": "This is SOURCE DATA for import, not a direct database dump. The sync script transforms this..."
}
```

### 2. Created JSON Schema
**File:** `/lib/data/schemas/agency-catalog.schema.json`

Defines structure with validation rules:
- Required fields: `agency`, `agencyName`, `version`, `lastUpdated`, `courses`
- Course validation: field types, ranges, format validation
- Max lengths, min/max values, enum constraints

### 3. Comprehensive README
**File:** `/lib/data/catalogs/README.md`

Documents:
- **Purpose**: Source data for fallback when APIs unavailable
- **Transformation Strategy**: How JSON → database records
- **Level Code Mapping**: `levelCode` (string) → `levelId` (UUID) lookup
- **Agency Lookup**: `agency` (string) → `agencyId` (UUID) lookup
- **Content Hash**: Generated from agency-controlled fields
- **Fields NOT Included**: Tenant-specific and database-specific fields

### 4. Validation Tests (78 tests)
**File:** `/tests/unit/data/padi-catalog.test.ts`

Tests cover:
- ✅ Metadata structure (agency, version, lastUpdated)
- ✅ Documentation comments explaining transformation
- ✅ Course structure (all required fields present)
- ✅ Valid `levelCode` values (beginner, advanced, professional, etc.)
- ✅ Unique course codes
- ✅ Field validation (ranges, lengths, formats)
- ✅ Data consistency (hours per day, prerequisites logic)
- ✅ **Transformation readiness** - all fields needed for `contentHash`
- ✅ **No tenant fields** (price, isActive, etc.)
- ✅ **No database fields** (id, agencyId, timestamps, etc.)
- ✅ Sample data quality (PADI progression: OWD → AOWD → RD → DM)

All 78 tests pass ✅

## Transformation Flow (Task 9)

The seed/sync script will transform this JSON into database records:

```typescript
// Input: JSON course object
{
  "name": "Open Water Diver",
  "code": "OWD",
  "levelCode": "beginner",  // ← string code
  ...
}

// Step 1: Look up agency
const agency = await db.query.certificationAgencies.findFirst({
  where: eq(certificationAgencies.code, 'padi')
});

// Step 2: Map level code to level ID
const levelMapping = {
  "beginner": "owd",
  "advanced": "aowd",
  "professional": "dm",
  ...
};
const level = await db.query.certificationLevels.findFirst({
  where: and(
    eq(certificationLevels.agencyId, agency.id),
    eq(certificationLevels.code, levelMapping['beginner'])
  )
});

// Step 3: Generate content hash
const contentHash = sha256(JSON.stringify({
  name, code, description, images,
  durationDays, classroomHours, poolHours, openWaterDives,
  prerequisites, minAge, medicalRequirements,
  requiredItems, materialsIncluded
}));

// Output: Database record
await db.insert(agencyCourseTemplates).values({
  id: uuid(),
  agencyId: agency.id,        // ← Added by script
  levelId: level.id,          // ← Looked up by script

  // Agency fields from JSON
  name: "Open Water Diver",
  code: "OWD",
  description: "...",
  images: ["..."],
  durationDays: 3,
  classroomHours: 8,
  poolHours: 8,
  openWaterDives: 4,
  prerequisites: null,
  minAge: 10,
  medicalRequirements: "...",
  requiredItems: ["..."],
  materialsIncluded: true,

  // Tracking fields added by script
  contentHash: "abc123...",   // ← Generated by script
  sourceType: 'static_json',  // ← Set by script
  sourceUrl: null,
  lastSyncedAt: new Date(),
  createdAt: new Date(),
  updatedAt: new Date()
});
```

## Why This Approach is Correct

### Evidence from Implementation Plan

**Line 83:** `source_type TEXT NOT NULL` can be `'api'`, `'static_json'`, or `'manual'`
- This field is added by the sync script, not in source data

**Lines 166-184:** Background sync job flow
```typescript
try {
  courses = fetchFromAPI(agency, timeout: 10s)
  upsertTemplates(courses, sourceType: 'api')
} catch {
  courses = readJSON(`catalogs/${agency.code}-courses.json`)
  upsertTemplates(courses, sourceType: 'static_json')  // ← Sets sourceType during import
}
```

**Lines 481-492:** File structure shows JSON files as source data
```
lib/data/catalogs/
├── padi-courses.json      ← Source data
├── ssi-courses.json       ← Source data
└── ...
```

### Benefits of Source Data Format

1. **Clean, Human-Readable** - Easy to maintain and update
2. **Agency-Focused** - Only course information, no database cruft
3. **Git-Friendly** - Clear diffs when courses change
4. **Separation of Concerns** - JSON = what courses are, DB = how they're stored
5. **Flexible** - Same format works for API responses and static files

## Files Modified

1. **lib/data/catalogs/padi-courses.json** - Added documentation header
2. **lib/data/catalogs/README.md** - Created comprehensive documentation
3. **lib/data/schemas/agency-catalog.schema.json** - Created JSON schema
4. **tests/unit/data/padi-catalog.test.ts** - Created 78 validation tests

## Next Steps (Task 9)

The seed script will:
1. Read `padi-courses.json`
2. Look up `agencyId` from `certification_agencies` where `code='padi'`
3. Map `levelCode` to `levelId` via `certification_levels` lookup
4. Generate `contentHash` from agency-controlled fields
5. Insert records into `agency_course_templates` with `sourceType='static_json'`

## Commit

```
feat(DIVE-2m4): Add PADI static JSON catalog with schema and comprehensive tests

Task 4 Implementation - Static JSON Source Data (PADI)
```

**All tests pass:** 78/78 ✅

## Summary

The JSON catalog is **correctly structured as source data**. The transformation to database records will happen in the seed script (Task 9). This approach:
- Keeps JSON clean and maintainable
- Aligns with the design spec's three-tier fallback system
- Passes comprehensive validation tests
- Documents transformation expectations clearly
